--[[
   Main module for Python numpy backend support
   2018, KU Leuven, Belgium
   License: BSD 2-clause
--]]
local tpl       = require('ilk.template-text').template_eval
local keys      = require('ilk.parser').keys
local comm      = require('ilk.common')
local jlcomm    = require('ilk.julia.common')
local sourcegen = require('ilk.julia.source')
local testgen   = require('ilk.julia.test')
local backend   = require('ilk.julia.backend-symbols')


local lfs = require('lfs')


local poseValueExpression = function(program, signature)
  local mc = nil
  for i,p in ipairs(signature.inputs) do
    if p.meta.metatype==comm.metatypes.modelConsts then
      mc = p.name
    end
  end
  if mc==nil then error("Fatal, could not find the ModelConstants parameter in the signature of program "..program.source.meta.solver_id) end
  return
  function(poseid)
    if program.model_poses.constant[poseid] ~= nil then
      return mc..".".. poseid
    else
     return poseid
   end
 end
end


local function source(context, programs, config)
  local funcs = {}
  for i,prog in ipairs(programs) do
    if prog.source.meta.solver_type == keys.solverKind.fk then
      funcs[i] = sourcegen.fksource(prog, context, config)
    else
      funcs[i] = sourcegen.iksource(prog, context, config)
    end
  end

  local env = {
    date       = os.date("!%c"),
    moduleName = context.mainModule,
    backend    = context.backendModule,
    modelConsts= sourcegen.modelConstsCTor(context, config),
    funcs      = funcs
  }
  local template=
[[
# This file was automatically generated by the ILK-compiler on «date»

module «moduleName»

import LinearAlgebra
import «backend»

${modelConsts}


@for i,f in ipairs(funcs) do
${f}

@end

end

]]
  return comm.tplEval_failOnError(template,env, {verbose=true, xtendStyle=true})
end


local function generator(ocontext, src_programs, config)

  -- Augment the context, with Julia specific context information :
  local context = {
    outer = ocontext,
    mainModule = ocontext.robotName,
    backendModule = "ILKBackend"
  }
  context.qualifiedBackendFunction=
    function(fMetaName)
      return context.backendModule .. "." .. backend.funcs[fMetaName]
    end
  context.matrixInitExpr =
    function(r,c)
      return context.qualifiedBackendFunction("matrixInit").."("..r..","..c..")"
    end

  -- Also augment the program model, with Python specific stuff
  local programs = {}
  for i, prog in ipairs( src_programs ) do
    local sign = jlcomm.signature(prog, context)
    programs[i] = {
      source=prog,
      signature=sign,
      poseValueExpression = poseValueExpression(prog, sign)
    }
  end
  context.programs = programs




  local testPath = config.path
  lfs.mkdir(testPath)
  local testFiles = {}
  local function genTestFile(program, text)
    local testFileName = program.source.meta.solver_id -- same as the solver-ID
    table.insert(testFiles,testFileName)
    local fdtest = io.open(testPath.."/"..testFileName..".jl", "w")
    fdtest:write( text )
    fdtest:close()
  end


  local mycfg = {
    importBackendAs = "ILKBackend"
  }

  -- Source files generation

  -- Main source
  local sourcetext = source(context, programs, mycfg)
  local fd = io.open(config.path.."/"..config.sourceFileName..".jl", "w") or io.stdout
  fd:write(sourcetext)
  fd:close()

  -- Test programs
  local testsGenerator = testgen(context, mycfg)
  local testtext
  for i,prog in ipairs(programs) do
    local solverTestsGenerator = testsGenerator(prog)

    if prog.source.meta.solver_type == keys.solverKind.fk then
      testtext = solverTestsGenerator.numericComparison(prog)
      genTestFile(prog, testtext)
    else
      testtext = solverTestsGenerator.fkConsistency(prog, context, mycfg)
      genTestFile(prog, testtext)
    end
  end
end

return generator
