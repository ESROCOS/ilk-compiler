--[[
   Module for generating source code of an ilk program in Octave
   License: BSD 2-clause
--]]

local common = require('ilk.common')
local keys = require("ilk.parser").keys
local ilk_special_ids = require("ilk.parser").special_IDs

local tplengine = require("ilk.backend.common.tpleval")
local opsHandlers = require("ilk.backend.common.ops-handlers")
local jointTransformsGenerator = require("ilk.backend.common.joint-transforms")

local thisBackendCommons = require('ilk.backend.octave.common')
local thisBackendMetaAPI = require('ilk.backend.octave.backend-symbols')
local thisBackendOpsHandlers = require('ilk.backend.octave.ops')


local function tpl(body, env, ret_table, included)
    local ok,text = tplengine.load_eval(body, env, {returnTable=ret_table or false}, included)
    if not ok then
        error("Failed to evaluate template: " .. text, 2)
    end
    return text
end


local heading_template = [[
%% This file was automatically generated by the Octave backend of the
%% ILK-compiler, on «date».
]]

local heading = tpl(heading_template, {date=os.date()}, true)


local source_model_constants = function(context, config)
    local env = {
        heading = heading,
        model_name = context.outer.robotName,
        class_name = config.codeTweaks.model_constants_class_name,
        poses  = function() return common.alphabPairs(context.outer.modelValues.poses) end,
        identity = thisBackendCommons.special_IDs[ ilk_special_ids.identity_matrix ],
        ilk_id_for_identity = ilk_special_ids.identity_matrix,
    }
    local res = tpl(
[[
${heading}

% The geometry constants for the robot model '«model_name»', in the form of
% homogeneous coordinate transforms, which encode the pose of the frame of any
% joint with respect to the frame of the predecessor link.

classdef «class_name»

properties(Constant)
@for id, val in poses() do
@   if val == ilk_id_for_identity then
«id» = eye(4);
@   else
«id» = [ [«val.r[1]» «val.r[2]» «val.r[3]» «val.p[1]»];
         [«val.r[4]» «val.r[5]» «val.r[6]» «val.p[2]»];
         [«val.r[7]» «val.r[8]» «val.r[9]» «val.p[3]»];
         [0 0 0 1] ];
@   end
@end

«identity» = eye(4);
end

end
]], env)

  return res
end



local source_fk = function(program, context, config)
    local env = {
        heading = heading,
        joint_transforms = jointTransformsGenerator.setJointTransforms(program, thisBackendMetaAPI),
        compiled_ops = function() return opsHandlers.translate(program, thisBackendOpsHandlers) end,
        program = program,
    }
    local template = [[
${heading}

«program.signature.toString()»

% update the joint transforms:
%
${joint_transforms}

% the solver's operations:
%
@for op, code_for_the_operation in compiled_ops() do
${code_for_the_operation}
@end

]]
    local code = tpl(template, env)
    return code
end


local ik_position_source = function(program, context, config, fkSolver)
    local configSpace = program.source.meta.solver_specs.configSpace
    local cfgVar = program.signature.inputs[2].name

    local env = {
        heading = heading,
        signature = program.signature,
        fkSolver  = fkSolver,
        fkargs = {
            program.signature.inputs[1].name,
            program.signature.outputs[1].name -- the joint status
        },
        cfgVar = cfgVar,
        backend = thisBackendMetaAPI,
    }

  env.deso = nil
  env.desp = nil
  env.compute_pos = false
  env.compute_or = false
  env.while_conditions = ''
  if configSpace == "location" then
      env.compute_pos = true
      env.while_conditions = '(ep > '..cfgVar..'.eps_pos_err_norm)'
      env.desp = program.signature.inputs[3].name
  elseif configSpace == "orientation" then
      env.compute_or = true
      env.while_conditions = '(eo > '..cfgVar..'.eps_or_err_norm)'
      env.deso = program.signature.inputs[3].name
  elseif configSpace == "pose" then
      env.compute_pos = true
      env.compute_or = true
      env.while_conditions = '((ep > '..cfgVar..'.eps_pos_err_norm) || (eo > '..cfgVar..'.eps_or_err_norm))'
      env.desp = program.signature.inputs[3].name
      env.deso = program.signature.inputs[4].name
  end
  local template =
[[
${heading}

«signature.toString()»
@if compute_pos then
    ep = «cfgVar».eps_pos_err_norm*10;
@end
@if compute_or then
    eo = «cfgVar».eps_or_err_norm*10;
@end
@local q_ik = fkargs[2]
@local dbg  = signature.outputs[2].name
    «q_ik» = q_guess;
    «dbg» = «backend.funcs.ikPosDebug»();
    ik_twist = «backend.matrixT(6,1)»;
    while( «while_conditions» && «dbg».iter_count < «cfgVar».max_iter)
        [pose, jacobian] = «fkSolver.signature.toString({call=true, args=fkargs})»;
@if compute_or then
        R = pose(1:3,1:3);
        ee_err_or  = «backend.funcs.orientDist»(«deso», R);
        ik_twist(«backend.funcs.angularCoords»()) = R * (ee_err_or.axis * sin(ee_err_or.angle)/«cfgVar».dt);
@end
@if compute_pos then
        ee_err_pos = «desp» - pose(1:3,4);
        ik_twist(«backend.funcs.linearCoords»()) = ee_err_pos / «cfgVar».dt;
@end
        qd = «backend.funcs.lsSolve»(jacobian, ik_twist);
        «q_ik» = «q_ik» + qd * «cfgVar».dt;
@if compute_pos then
        ep = norm(ee_err_pos);
@end
@if compute_or then
        eo = abs(ee_err_or.angle);
@end
        «dbg».iter_count = «dbg».iter_count + 1;
    end

    «dbg».actual_pos = pose(1:3,4);
    «dbg».actual_or  = pose(1:3,1:3);
]]
    local code = tpl(template, env)
    return code
end


local ik_velocity_source = function(program, context, config, fkSolver)
    local configSpace = program.source.meta.solver_specs.configSpace
    local env = {
        signature= program.signature,
        fkSolver = fkSolver,
        fkargs = {
          [1] = program.signature.inputs[1].name,
          [2] = program.signature.inputs[2].name
        },
        configSpace  = configSpace,
        jacVar = "J",
        backend = thisBackendMetaAPI,
    }

  local templ =
[[
«signature.toString()»
    [~, «jacVar»] = «fkSolver.signature.toString({call=true, args=fkargs})»
@if configSpace ~= "pose" then
    aux = «jacVar»(«backend.coordsSpan[configSpace]»,:);
@end
    «signature.outputs[1].name» = «backend.funcs.lsSolve»(aux, «signature.inputs[3].name»);
]]
    local code = tpl(templ, env)
    return code
end

local source_ik = function(program, context, config)
    if program.source.meta.solver_type ~= keys.solverKind.ik.position and
       program.source.meta.solver_type ~= keys.solverKind.ik.velocity then
        error("This generator is meant only for inverse kinematics routines")
    end

    local ikid = program.source.meta.solver_id
    local fkid = program.source.meta.solver_specs.fkSolverID
    local fkSolver, i = common.findProgramByID(fkid, context.outer)
    if fkSolver == nil then
        error("Could not find the parsed model of FK solver "..fkid..
              ", required by IK solver ".. ikid)
    end
    -- now find the backend-augmented version of the FK solver object
    local fkSolver2 = context.programs[i]
    if fkSolver2 == nil then
        error("Could not find the FK solver model '" ..fkid..
              "' in the list of programs in the current context" ..
              " (while processing the IK solver '".. ikid .. "')")
    end
    if fkSolver2.source ~= fkSolver then
        error(string.format("Inconsistency while processing IK solver '%s': "..
            "mismatch between the required FK solver model ('%s') in the " ..
            "regular and augmented context", fkid, ikid))
    end

    if program.source.meta.solver_type == keys.solverKind.ik.position then
        return ik_position_source(program, context, config, fkSolver2)
    else
        return ik_velocity_source(program, context, config, fkSolver2)
    end
end


return {
    model_constants = source_model_constants,
    solver_fk = source_fk,
    solver_ik = source_ik,
    heading_template = heading_template,
}
