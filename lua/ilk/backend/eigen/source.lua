
local tpl = require('template-text').template_eval
local backend = require('ilk.backend.eigen.backend-symbols')
local cppcom = require('ilk.backend.eigen.common')
local cppops = require('ilk.backend.eigen.ops')
local com = require('ilk.common')
local keys = require("ilk.parser").keys

local M = {}

local code_jointTransformLocals = function(program)
    local code = {}
    for t,_ in com.alphabPairs(program.source.model_poses.joint) do
        if program.source.meta.outputs[t]==nil then
            table.insert(code, cppcom.typeString(com.metatypes.pose) .. ' ' .. t .. ';')
        end
    end
    return code
end




local modelConstsCTor = function(context)

  local env = {
    ns     = context.namespace.qualifier(),
    struct = cppcom.typeString("ModelConstants"),
    modelValues = context.outer.modelValues,
    sorted = com.alphabPairs,

    setOneCode = function(poseid, value)
      local ok,res = tpl([[
«poseid».setIdentity();
«funcs.setPosition»(«poseid»,«val.p[1]»,«val.p[2]»,«val.p[3]»);
«funcs.setRotation»(«poseid»,«val.r[1]»,«val.r[2]»,«val.r[3]»,
                             «val.r[4]»,«val.r[5]»,«val.r[6]»,
                             «val.r[7]»,«val.r[8]»,«val.r[9]»);
]],   {funcs = backend.funcs, poseid=poseid, val=value},
      {xtendStyle=true, returnTable=true})
      return res
    end
  }

  local ret = {}
  local ok,res = tpl([[
«ns»::«struct»::«struct»()
{
    @for k, v in sorted(modelValues.poses) do
    @  local one = setOneCode(k, v )
    ${one}

    @end
}
]], env,
  {xtendStyle=true, returnTable=true})
  return res
end


M.heading = function(context, cfg)
  local env = {
    date = os.date("!%c"),
    ns     = cppcom.backendNS.qualifier(),
    mcCTor = modelConstsCTor(context),
    header = cfg.headerFileName
  }
  local ok, res = tpl(
[[
/*
 * Source code generated by the ILK-compiler, C++/Eigen backend
 * File generated on: «date» (UTC)
 */
#include "«header».h"
#include <ilk/eigen/gjac.h>
#include <ilk/eigen/ctransforms.h>

using namespace «ns»;

${mcCTor}


]], env, {verbose=true, xtendStyle=true})
  return res
end

local ops_handlers = require("ilk.backend.common.ops-handlers")
local jointTransforms = require("ilk.backend.common.joint-transforms")

M.fksource = function(program, context, opsHandlers)
  local aux = {
    jointTransformSetvalue = backend.jointTransformSetvalue
  }

  local jTransf = jointTransforms.setJointTransforms(program, aux)

  local env = {
      signature = program.signature.toString({declaration=false}),
      defs = code_jointTransformLocals(program),
      jTransf = jTransf,
      compiled_ops = function() return ops_handlers.translate(program, opsHandlers) end
  }
  local templ =
[[
«signature»
{
    ${defs}

    ${jTransf}

  @ for op, code in compiled_ops() do
    ${code}
  @ end
}
]]
  return com.tplEval_failOnError(templ, env, {xtendStyle=true})
end


local ikgen = {

[keys.solverKind.ik.velocity] =
function(program, context)
  local configSpace = program.source.meta.solver_specs.configSpace
  local env = {
    metat    = com.metatypes,
    typeh    = cppcom,
    signature= program.signature,
    fkSolver = program.fkSolver,
    fkargs = {
      [1] = program.signature.inputs[1].name,
      [2] = program.signature.inputs[2].name,
      [3] = "fk_solution",
      [4] = "J"
    },
    leastSquares = cppcom.backendNS.qualifier().."::"..backend.funcs.lsSolve,
    configSpace  = configSpace,
    jacVar = "J"
  }

  local ok, res = tpl(
[[
«signature.toString({declaration=false})»
{
    «typeh.typeString(metat.pose)» «fkargs[3]»;
    «typeh.typeString(metat.jacobian)» «fkargs[4]»;
    «fkSolver.signature.toString({call=true, args={fkargs[1],fkargs[2],fkargs[3], fkargs[4]}})»;
@if configSpace ~= "pose" then
    «typeh.matrixBlockExpr(fkargs[4], 6, configSpace ).defAndInit("aux")»
@   jacVar = "aux"
@end
    «leastSquares»(«jacVar», «signature.inputs[3].name», «signature.outputs[1].name»);
}
]], env, {verbose=true, xtendStyle=true, returnTable=false})

  if not ok then
    error(res)
  end
  return res
end,

[keys.solverKind.ik.position] =
function(program, context)
  local configSpace = program.source.meta.solver_specs.configSpace
  local cfgVar = program.signature.inputs[2].name
  local env = {
    metat    = com.metatypes,
    signature= program.signature,
    fkSolver = program.fkSolver,
    fkargs = {
      [1] = program.signature.inputs[1].name,
      [2] = program.signature.outputs[1].name, -- the joint status
      [3] = "fk_solution",
      [4] = "J"
    },
    cfgVar = cfgVar,
    beNS = cppcom.backendNS.qualifier(),
    backend = backend,
    funcs= backend.funcs,
    typ = function(id) return cppcom.typeString(id, {nsQualified=true}, context) end
  }
  env.deso = nil
  env.desp = nil
  env.compute_pos = false
  env.compute_or = false
  env.while_conditions = ''
  if configSpace == "location" then
      env.compute_pos = true
      env.while_conditions = '(ep > '..cfgVar..'.eps_pos_err_norm)'
      env.desp = program.signature.inputs[3].name
  elseif configSpace == "orientation" then
      env.compute_or = true
      env.while_conditions = '(eo > '..cfgVar..'.eps_or_err_norm)'
      env.deso = program.signature.inputs[3].name
  elseif configSpace == "pose" then
      env.compute_pos = true
      env.compute_or = true
      env.while_conditions = '(ep > '..cfgVar..'.eps_pos_err_norm || eo > '..cfgVar..'.eps_or_err_norm)'
      env.desp = program.signature.inputs[3].name
      env.deso = program.signature.inputs[4].name
  end
  local ok, res = tpl(
[[
«signature.toString({declaration=false})»
{
    using namespace std;
@if compute_pos then
    «typ(metat.position3d)» ee_err_pos;
    double ep = «cfgVar».eps_pos_err_norm*10;
@end
@if compute_or then
    «typ(metat.axisAngle)» ee_err_or;
    double eo = «cfgVar».eps_or_err_norm*10;
@end
@local q_ik = fkargs[2]
@local dbg  = signature.outputs[2].name

    «typ(metat.twist)» ik_twist(«typ(metat.twist)»::Zero());
    «typ(metat.jacobian)» «fkargs[4]»;
    «typ(metat.pose)» «fkargs[3]»;
    «typ(metat.jointState)» qd;
    «q_ik» = q_guess;

    «dbg».iter_count = 0;
@if compute_or then
    «backend.matrixT(3,3)» R;
@end

    while( «while_conditions» && «dbg».iter_count < «cfgVar».max_iter)
    {
        «fkSolver.signature.toString({call=true, args={fkargs[1],fkargs[2],fkargs[3], fkargs[4]}})»;
@if compute_or then
        R = «beNS»::«funcs.rotView»(«fkargs[3]»);
        ee_err_or  = «beNS»::«funcs.orientDist»(«deso», R);
        angularCoords(ik_twist ) = R * (ee_err_or.axis * std::sin(ee_err_or.angle)/«cfgVar».dt);
@end
@if compute_pos then
        ee_err_pos = «desp» - «beNS»::«funcs.posView»(«fkargs[3]»);
        linearCoords( ik_twist ) = ee_err_pos / «cfgVar».dt;
@end
        «beNS»::«funcs.lsSolve»(«fkargs[4]», ik_twist, qd);
        «q_ik» += qd * «cfgVar».dt;
@if compute_pos then
        ep = ee_err_pos.norm();
@end
@if compute_or then
        eo = std::abs(ee_err_or.angle);
@end
        «dbg».iter_count++;
    }
    «dbg».actual_pos = «beNS»::«funcs.posView»(«fkargs[3]»);
    «dbg».actual_or  = «beNS»::«funcs.rotView»(«fkargs[3]»);
}
]], env, {verbose=true, xtendStyle=true, returnTable=false})

  if not ok then
    error(res)
  end
  return res
end

}



M.iksource = function(program, context)
  if program.source.meta.solver_type ~= keys.solverKind.ik.position and
     program.source.meta.solver_type ~= keys.solverKind.ik.velocity then
    error("This generator is meant only for inverse kinematics routines")
  end

  local fkSolver = cppcom.findProgramByID(program.source.meta.solver_specs.fkSolverID, context)
  if fkSolver == nil then
    error("Could not find the parsed model of FK solver "..program.source.meta.solver_specs.fkSolverID..
          ", required by IK solver "..program.source.meta.solver_id)
  end
  program.fkSolver = fkSolver

  return ikgen[program.source.meta.solver_type](program, context)


end


return M
