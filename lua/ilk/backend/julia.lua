--[[
   Main module for Python numpy backend support
   2018, KU Leuven, Belgium
   License: BSD 2-clause
--]]
local keys      = require('ilk.parser').keys
local comm      = require('ilk.common')
local jlcomm    = require('ilk.backend.julia.common')
local sourcegen = require('ilk.backend.julia.source')
local testgen   = require('ilk.backend.julia.test')
local backend   = require('ilk.backend.julia.backend-symbols')


local lfs = require('lfs')


local poseValueExpression = function(program, signature)
  local mc = nil
  for i,p in ipairs(signature.inputs) do
    if p.meta.metatype==comm.metatypes.modelConsts then
      mc = p.name
    end
  end
  if mc==nil then error("Fatal, could not find the ModelConstants parameter in the signature of program "..program.source.meta.solver_id) end
  return
  function(poseid)
    if program.model_poses.constant[poseid] ~= nil then
      return mc..".".. poseid
    else
     return poseid
   end
 end
end


local function source(context, programs, opsHandlers, codeTweakConfig)
  local funcs = {}
  for i,prog in ipairs(programs) do
    if prog.source.meta.solver_type == keys.solverKind.fk then
      funcs[i] = sourcegen.fksource(prog, context, opsHandlers, codeTweakConfig)
    else
      funcs[i] = sourcegen.iksource(prog, context, codeTweakConfig)
    end
  end

  local env = {
    date       = os.date("!%c"),
    moduleName = context.mainModule,
    backend    = context.backendModule,
    modelConsts= sourcegen.modelConstsCTor(context, codeTweakConfig),
    funcs      = funcs
  }
  local template=
[[
# This file was automatically generated by the ILK-compiler on «date»

module «moduleName»

import LinearAlgebra
import «backend»

${modelConsts}


@for i,f in ipairs(funcs) do
${f}

@end

end

]]
  return comm.tplEval_failOnError(template,env, {verbose=true, xtendStyle=true})
end


local function augmentContext(oContext, sourcePrograms)
  -- Augment the context, with Julia specific context information :
  local context = {
    outer = oContext,
    mainModule = oContext.robotName,
    backendModule = "ILKBackend"
  }
  context.qualifiedBackendFunction=
    function(fMetaName)
      return context.backendModule .. "." .. backend.funcs[fMetaName]
    end
  context.matrixInitExpr =
    function(r,c)
      return context.qualifiedBackendFunction("matrixInit").."("..r..","..c..")"
    end

  context.opsHandlers = require("ilk.backend.julia.ops").closuresOnContext(context)

  -- Also augment the program model, with Julia specific stuff
  local programs = {}
  for i, prog in ipairs( sourcePrograms ) do
    local sign = jlcomm.signature(prog, context)
    programs[i] = {
      source=prog,
      signature=sign,
      poseValueExpression = poseValueExpression(prog, sign)
    }
  end
  context.programs = programs
  return context, programs
end


local function getGenerator(opsHandlers, codeTweakConfig)

local function generator(context, programs, config)
  local testPath = config.path
  lfs.mkdir(testPath)
  local testFiles = {}
  local function genTestFile(program, text)
    local testFileName = program.source.meta.solver_id -- same as the solver-ID
    table.insert(testFiles,testFileName)
    local fdtest = io.open(testPath.."/"..testFileName..".jl", "w")
    fdtest:write( text )
    fdtest:close()
  end

  -- Source files generation

  -- Main source
  local sourcetext = source(context, programs, opsHandlers, codeTweakConfig)
  local fd = io.open(config.path.."/"..config.sourceFileName..".jl", "w") or io.stdout
  fd:write(sourcetext)
  fd:close()

  -- Test programs
  local testsGenerator = testgen(context, codeTweakConfig)
  local testtext
  for i,prog in ipairs(programs) do
    local solverTestsGenerator = testsGenerator(prog)

    if prog.source.meta.solver_type == keys.solverKind.fk then
      testtext = solverTestsGenerator.numericComparison(prog)
      genTestFile(prog, testtext)
    else
      testtext = solverTestsGenerator.fkConsistency(prog, context, codeTweakConfig)
      genTestFile(prog, testtext)
    end
  end
end

  return generator
end

local function getGenerators(context, sourceTweakConfig)
  local opsHandlers = require("ilk.backend.julia.ops").closuresOnContext(context)
  local generator = getGenerator(opsHandlers, sourceTweakConfig)

  return opsHandlers, generator
end


return {
  augmentContext = augmentContext,
  getGenerators  = getGenerators
}
