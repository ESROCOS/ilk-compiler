#!/usr/bin/env lua

utils = require('ilk.utils')
local ansicolors = require('ilk.ansicolors')
local vlog  = require('ilk.vlog')

--- helper, print a bright red errormsg
function errmsg(...)
   print(ansicolors.bright(ansicolors.red(table.concat({...}, ' '))))
end

--- helper, print a yellow warning msg
function warnmsg(...)
   print(ansicolors.yellow(table.concat({...}, ' ')))
end

--- helper, print a green sucess msg
function succmsg(...)
   print(ansicolors.green(table.concat({...}, ' ')))
end

function usage()
  print( [[
ilk-compiler: C/C++ compiler for kin-ir language

Usage: gen-offline [OPTIONS]
    -i          <input-file>     input language (.ilk)
    -b          <option>         backend option [eigen, gsl]
    -o          <filename>       output (generated C/C++ source)
    -m          <path>           generate makefile in <path> (optional)
    --indir     <path>           folder with all input files 
                                    (.ilk + model-constants + robot-defs.h)
    --outdir    <folder>         all files generated in <folder> (optional),
                                 outdir override options [-m, -o]
    --compile   (NONE)           compile the output (optional)
    
    -h        prints this help
]])
end
  
geom_relations = {
  'Position',
  'Orientation',
  'Pose',
  'LinearVelocity',
  'AngularVelocity',
  'Twist',
  'Torque',
  'Force',
  'Wrench' 
}

types_gsl = {
    Pose        = {typedef = false, tname='grc_transformation_matrix_gsl', init='grc_transformation_matrix_gsl_setup'},
    Position    = {typedef = false, tname='struct grc_position_vector_gsl',init='grc_position_vector_gsl_setup'},
    Orientation = {typedef = false, tname='struct grc_rotation_matrix_gsl',init='grc_rotation_matrix_gsl_setup'}
}
  
types_eigen = {
  Pose        = {typedef = true, tname='pose_t',
    views = { Position = 'position_v', Orientation = 'rot_m_v'} },
  Position    = {typedef = true, tname='position_t'},
  Orientation = {typedef = true, tname='rot_m_t'}
}

model = {
  T_B_L1 = { numeri },
}

-- In a separate file now, option [-s]
-- model_values = {
--   const_T_B_L1 = {
--     p = {1,0,0},
--     r = {1,0,0,0,1,0,0,0,1}
--   },
--   const_T_L2_L3 = {
--     p = {1,0,2},
--     r = {1,0,0,0,1,0,0,0,1}
--   }
-- }

--[[ TODO:
not smart generation of views --> generate only the one needed,
instead of all (aka output required from query)
--]]    
local var_op_eigen = function(state,args,idx)
  local pose_template = [[

$(space)$(tname) $(varname);
$(space)$(varname).setIdentity();
@ if views then
@   for i,v in pairs(views) do
@    if i == 'Position' then
$(space)$(v) $(varname)_$(i) = eg_get_position($(varname));
@    elseif i == 'Orientation' then
$(space)$(v) $(varname)_$(i) = eg_get_rotation($(varname));
@    end
@   end
@ end

]]
  local templates = {
    Pose = pose_template
  }
  local fd  = state.fd or io.stdout
  local idx = idx or 0
  local tname   = types_eigen[args[1]].tname
  local views   = types_eigen[args[1]].views
  local varname = args[2]
  local typedef = types_gsl[args[1]].typedef
  local ok, res = utils.preproc(templates[args[1]],
  {table=table, pairs=pairs, space=utils.gen_spaces('\t',idx), 
    tname=tname, varname=varname, 
    typedef=typedef, views=views})
  if not ok then error(res) end
  state.vars[#state.vars+1] = {varname=varname,tname=tname}
  fd:write(res)
end

var_op_gsl = function(state,args,idx)
  local fd  = state.fd or io.stdout
  local idx = idx or 0
  local tname   = types_gsl[args[1]].tname
  local varname = args[2]
  local typedef = types_gsl[args[1]].typedef
  local ok, res = utils.preproc([[
@ if typedef then
$(space)$(tname) $(varname);
@ else
$(space)struct $(tname) $(varname);
@ end
$(space)$(init)(&$(varname));
$(space)grc_transformation_matrix_gsl_init_identity(&$(varname));

]],
  {table=table, space=utils.gen_spaces('\t',idx), 
    tname=tname, varname=varname, 
    typedef=typedef,
    init=types_gsl[args[1]].init})
  if not ok then error(res) end
  state.vars[#state.vars+1] = {varname=varname,tname=tname}
  fd:write(res)
end

compose_op_gsl = function(state,args,idx)
  local fd  = state.fd or io.stdout
  local idx = idx or 0
  local ok, res = utils.preproc([[$(space)grc_transformation_matrix_gsl_compose(&$(args[1]),&$(args[2]),&$(args[3]));]]
, { table=table, space=utils.gen_spaces('\t',idx), args=args})
  if not ok then error(res) end
  fd:write(res)
end

--[[ TODO
  NOT OPTIMISED!
  Use of temporal as described in the program, but I could fetch a full 
  chunk of 'compose' operations and concatenate them, considering the output
  requested by the query
--]]
compose_op_eigen = function(state,args,idx)
  local fd  = state.fd or io.stdout
  local idx = idx or 0
  local ok, res = utils.preproc([[$(space)$(args[3]) = $(args[1]) * $(args[2]);]]
, { table=table, space=utils.gen_spaces('\t',idx), args=args})
  if not ok then error(res) end
  fd:write(res)
end

--support only transformation_matrix
print_op_gsl = function(state,args,idx)
  local fd  = state.fd or io.stdout
  local idx = idx or 0
  local ok, res = utils.preproc([[
@ for i,v in pairs(args) do
$(space)for(unsigned int i=0;i<3;i++) {
$(space)  printf("%f ", ($(v).origin)->data[i]);
$(space)}
$(space)printf("\n");
@ end
]], {table=table, args=args,pairs=pairs, space=utils.gen_spaces('\t',idx)})
  if not ok then error(res) end
  fd:write(res)
end

--support only transformation_matrix(Pose)
print_op_eigen = function(state,args,idx)
  local fd  = state.fd or io.stdout
  local idx = idx or 0
  local ok, res = utils.preproc([[
@ for i,v in pairs(args) do
$(space)std::cout << "---- $(v) ----" << std::endl;
$(space)std::cout << $(v) << std::endl;
$(space)std::cout << "--------------" << std::endl;
@ end
]], {table=table, args=args,pairs=pairs, space=utils.gen_spaces('\t',idx)})
  if not ok then error(res) end
  fd:write(res)
end

-- supports only transformation_matrix
set_op_gsl = function(state,args,idx)
  local fd  = state.fd or io.stdout
  local idx = idx or 0

  local values = model_values[args[2]]
  local ok, res = utils.preproc([[
@ if not anyset then
$(space)struct grc_rotation_matrix_gsl *r = grc_rotation_matrix_gsl_construct_and_setup();
$(space)struct grc_position_vector_gsl *p = grc_position_vector_gsl_construct_and_setup();
@ end
$(space)grc_position_vector_gsl_init_from_xyz(p,$(values.p[1]),$(values.p[2]),$(values.p[3]));
$(space)grc_rotation_matrix_gsl_init_from_entries(r,$(values.r[1]),$(values.r[2]),$(values.r[3]),
$(space)    $(values.r[4]),$(values.r[5]),$(values.r[6]),
$(space)    $(values.r[7]),$(values.r[8]),$(values.r[9]));
$(space)grc_transformation_matrix_gsl_init_from_rotation_matrix_and_position_vector(&$(target),r,p);

]], {space=utils.gen_spaces('\t',idx), table=table, values=values, target=args[1],anyset=state.anyset} )
  if not ok then error(res) end
  state.anyset=true
  fd:write(res)
end

-- supports only transformation_matrix
set_op_eigen = function(state,args,idx)
  local fd  = state.fd or io.stdout
  local idx = idx or 0

  local values = model_values[args[2]]
  local ok, res = utils.preproc([[
$(space)eg_set_position($(target)_Position,$(values.p[1]),$(values.p[2]),$(values.p[3]));
$(space)eg_set_rotation($(target)_Orientation,$(values.r[1]),$(values.r[2]),$(values.r[3]),
$(space)    $(values.r[4]),$(values.r[5]),$(values.r[6]),
$(space)    $(values.r[7]),$(values.r[8]),$(values.r[9]));
]], {space=utils.gen_spaces('\t',idx), table=table, values=values, target=args[1]} )
  if not ok then error(res) end
  fd:write(res)
end

-- Poor's man implementation, hypothesis <tname>_cleanup API
local cleanup_gsl = function(state,idx)
  local fd  = state.fd or io.stdout
  local idx = idx or 0
  local ok, res = utils.preproc([[
@ for i,v in pairs(vars) do
$(space)$(v.tname)_cleanup(&$(v.varname));
@ end
]], {table=table, pairs=pairs, space=utils.gen_spaces('\t',idx), vars=state.vars})
  if not ok then error(res) end
  fd:write(utils.gen_spaces('\n\t',idx)..'/* cleaning up...  */\n')
  fd:write(res)
end

op_backend = {
  gsl = {
    var     = var_op_gsl,
    assign  = set_op_gsl,
    compose = compose_op_gsl,
    print   = print_op_gsl,
    cleanup = cleanup_gsl
  },
  eigen = {
    var     = var_op_eigen,
    assign  = set_op_eigen,
    compose = compose_op_eigen,
    print   = print_op_eigen,
    cleanup = function() end
  }
}


--[[ Backend-specific templates ]]--
local main_header_gsl = [[
/* This file is autogenerated by 'gen-offline' 
 *   2017, Enea Scioni, KU Leuven, Belgium
 *   
*/
#include <stdio.h>

#include "grc_gsl/grc_gsl_types.h"
#include "grc_gsl/position_vector.h"
#include "grc_gsl/rotation_matrix.h"
#include "grc_gsl/transformation_matrix.h"

int main(int argc, char** argv) {

]]

local main_footer_gsl = [[
      return 0;
}
]]


------------- HEADER GENERATION -----------------------------
-- Routine to generete the header file
-- It contains all the functions generated by the program
function gen_header_main(path,fn,config)
  local fd = io.open(path..fn..config.fextension,"w") or io.stdout
  local program = config.program
  local conf    = {fd=fd,filename=fn}
  -- Pre-processing phase
  local model_const = {}
  local outputs = {}
  for i,v in pairs(config.program) do
    if v.op == 'model_const' then
      -- generate type (fixed), because not yet in iLK
      for k,name in pairs(v.args) do
        model_const[#model_const+1] = {name=name, type='pose_t'}
      end
     elseif v.op == 'output' then
       outputs[#outputs+1] = v[1]
     end
  end
  -- HARDCODED -- types
  local olist = {}
  for i,v in pairs(outputs) do
    olist[#olist+1] = { "pose_t", v }
  end
  -- Generating
  config.main.header(conf)
  config.main.model_config(conf,
    {sname='config', model_const=model_const},1)
  config.main.gen_fnc_signature(conf,{fnc_name='fk_compute', sname='config',
   olist=olist,
   is_proto=true
  },1)
  config.main.footer(conf)
  fd:close()
end


function header_generator(config)
    local config = config
    config.main = {}
  if config.backend == 'eigen' then
    local eg_module = require('ilk.ilk-eigen')
    config.main = eg_module.header
    config.main.gen_fnc_signature = eg_module.source.gen_fnc_signature
    config.fextension   = '.h'
  else
    errmsg("The header file generation is not supported with the selected backend ("..config.backend..')'); os.exit(1)
  end
  
  return function(path,fn) gen_header_main(path,fn,config) end
end

function makefile_generator(config)
  local config = config
  local genm
  if config.backend == 'eigen' then
    genm = require('ilk.ilk-eigen').make.gen_makefile
  else
    errmsg("The generation of the makefile is not supported with the selected backend ("..config.backend..')'); os.exit(1)
  end
    
  return function(path,args)
    local fd = io.open(path..'/makefile','w')
    genm(fd,args)
    fd:close()
  end
end

-- function gen_main(fn,config)
--   local fd = io.open(fn,"w") or io.stdout
--   fd:write(config.main.header)
--   local operations = config.operations
--   local state = { fd=fd, vars={}, anyset=false}
--   for i,v in ipairs(config.program) do
--     operations[v.op](state,v.args,1)
--   end
-- 
--   operations['cleanup'](state,1)
--   fd:write(config.main.footer)
--   fd:close()
-- end

function gen_test(path,fn,config)
  local fd = io.open(path..fn..'_test.cpp',"w") or io.stdout
  local conf = {fd=fd, filename=fn}
  config.main.header(conf)
  config.main.footer(conf)
  fd:close()
end

function gen_main(path,fn,config)
  local fd = io.open(path..fn..config.fextension,"w") or io.stdout
  local internal_config = { fd=fd}
  
  -- step 0: pre-process the full program
  -- grouping by operation
  local m_joint_local = {}
  local compose = {}
  local model_const = {}
  local outputs = {}
  for i,v in pairs(config.program) do
    if v.op == 'model_T_joint_local' then
      m_joint_local[v.name] = v
    elseif v.op == 'compose' then --be aware, they are ordered
      compose[#compose+1] = v.args
    elseif v.op == 'output' then
      outputs[#outputs+1] = v[1]
    elseif v.op == 'model_const' then
      model_const = v.args
    end
  end
  -- HARDCODED -- types
  local olist = {}
  for i,v in pairs(outputs) do
    olist[#olist+1] = { "pose_t", v }
  end
  ------------------------------
  -- generation steps
  config.main.header(internal_config,{filename=fn},0)
  -- first, generate model constr
  config.main.gen_model_cnst(internal_config,{model_const=model_const,model_values=model_values, sname='config'},0)
  -- second, generate signature
  config.main.gen_fnc_signature(internal_config,{fnc_name='fk_compute', sname='config',
    olist=olist,
--    olist={{"pose_t", "link2_base"} , {"pose_t", "link3_base"}},
   is_proto=false--hardcoded, this is given
  },1)
  config.main.gen_fnc_body(internal_config,m_joint_local,1)
  config.main.gen_fnc_body2(internal_config,{outputs=outputs,
    compose=compose,
    model_const=model_const
    },1)
  config.main.footer(internal_config,{},0)
  fd:close()
end

-- selects the generator from the backend
local function source_generator(config)
  local config = config
  
  config.main = {}
  if config.backend == 'gsl' then
    config.main.header = main_header_gsl
    config.main.footer = main_footer_gsl
    config.operations  = op_backend.gsl
    config.fextension  = '.c'
  elseif config.backend == 'eigen' then
    config.main        = require('ilk.ilk-eigen').source
    config.operations  = op_backend.eigen
    config.fextension  = '.cpp'
  end
  
  return function(path,fn) gen_main(path,fn,config) end
end

local function test_generator(config)
  local config = config
  
  config.main = {}
  if config.backend == 'eigen' then
    config.main = require('ilk.ilk-eigen').test
    config.fextension  = '.cpp'
  else
    errormsg("the backend is not supported"); os.exit(1);
  end
  
  return function(path,fn) gen_test(path,fn,config) end
end
                      
---
-- Program enters here
-----------------------------------
local opttab=utils.proc_args(arg)

if #arg==1 or opttab['-h'] then usage(); os.exit(1) end

local input_req = false
local ilk
local sfile
local inputfolder = ""

if opttab['--indir'] then
  input_req = true
  inputfolder = opttab['--indir'][1]..'/'
  sfile = 'model-constants.lua'
  
  lfs=require('lfs')
  for file in lfs.dir(inputfolder) do
    local ext = utils.split(file,'[\\.]')[2]
    if ext == 'ilk' then
      ilk = file
      break
    end
  end
--   print(ilk)
--   print(sfile)
end


if not input_req then 
  if not (opttab['-i'] and opttab['-i'][1]) then
     errmsg("input missing (intermediate language source)  [-i]"); os.exit(1)
  end

  if not (opttab['-s'] and opttab['-i'][1]) then
     errmsg("input missing (static model values)  [-s]"); os.exit(1)
  end
  ilk         = opttab['-i'][1]
  sfile       = opttab['-s'][1]
end
  
--outdir option bypass -o
outdir = false
local mflag = false
if opttab['--outdir'] and opttab['--outdir'][1] then
  outdir = opttab['--outdir'][1]
  mflag  = outdir --makefile generated when outdir option is indicated
elseif not (opttab['-o'] and opttab['-o'][1]) then
   errmsg("missing output destination (generated C source) [-o]"); os.exit(1)
end

if not (opttab['-b'] and opttab['-b'][1]) then
   errmsg("missing backend, options are 'eigen', 'gsl'  [-b]"); os.exit(1)
end


if not outdir and opttab['-m'] then
   warnmsg("A makefile will be generated.")
   mflag = opttab['-m'][1]
end

backend     = opttab['-b'][1]

-- default output_file name -> .ilk entry
output_file = utils.split(ilk,'[\\.]')[1]..'.cpp'
if not outdir then output_file = opttab['-o'][1] end
local source_outputfile = output_file
local output_file = utils.split(source_outputfile,'[\\.]')[1]
path = ""
-- generate outdir folder and path
if outdir then
  os.execute('mkdir -p '..outdir)
  path = outdir..'/'
end

local cflag = false
if (opttab['--compile']) then
  if not mflag then
    warnmsg("option --compile is disabled when makefile is not generated")
  else
    cflag = opttab['--compile'][1] or path..output_file
    warnmsg("compile flag activated -- using "..backend..", target "..cflag)
  end
end

local chunk = loadfile(inputfolder..ilk)
local program = chunk()
chunk = loadfile(inputfolder..sfile)
model_values = chunk()  --TODO param me
-- RUN!

local cgen = source_generator({backend=backend, program=program})
cgen(path,output_file)
succmsg(output_file..'.cpp generated!')
local hgen = header_generator({backend=backend, program=program})
hgen(path,output_file)
succmsg(output_file..'.h generated!')
local tgen = test_generator({backend=backend, program=program})
tgen(path,output_file)
succmsg(output_file..'_test.cpp generated!')

if mflag then
  local mgen = makefile_generator({backend=backend})
  mgen(outdir,{libname=output_file, execname=output_file,path_support=nil})
  succmsg('makefile generated!')
  os.execute('cp '..inputfolder..'/robot-defs.h '..outdir..'/robot-defs.h')
  succmsg('copying robot definitions')
end

-- Post-process utility
-- (here, installing + AADL wrapper)
if cflag then
  if backend == 'gsl' then
    warnmsg('compiling...')
    os.execute('gcc -fPIC -g -pedantic -Wall -o '..cflag..' -L`pwd`/blas/grc_gsl/ '..output_file..' -lgrc')
    succmsg('           ...done!')
  end
  if backend == 'eigen' then
    warnmsg('compiling...')
--     os.execute('g++ $(pkg-config --cflags eigen3) -Ieigen/ -o '..cflag..' '..path..output_file..'_test.cpp '..path..source_outputfile..' eigen/joint-transforms.cpp')
    os.execute('cd '..outdir..' && make && cd ..')
    succmsg('           ...done!')
  end
end
